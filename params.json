{"name":"Common Javascript Idioms","tagline":"","body":"Javascript has a huge ecosystem. \r\n\r\n![At the time of writing there were 201,625 packages on npmjs.org](http://i.imgur.com/ctMWXCP.png)\r\n\r\nAt the time of writing there are 201,625 packages on the [Node Package Manager (NPM) website](https://www.npmjs.com/) \r\n\r\nWith a catalog of hundreds of thousands of libraries available to [Node.js](https://nodejs.org) developers, how do you make sure it's easy to get started with any of those libraries? \r\n\r\n**By speaking the same language!**\r\n\r\nThere are a handful of patterns so common in Javascript that you'll find them all in many libraries and at least one, and often many in _almost every library_.\r\n\r\n## Options POJO\r\n\r\nOften, you'll want to be able to configure a tool. When starting the Mocha test runner you might want to set the UI and the reporter. You can do that using a Plain Old Javascript Object. In JS an object is most commonly created using the literal syntax `{}` but can also be created using `new Object()` and is basically just a collection of \"key/value pairs\". The key is used to lookup a specified value and can be almost any object! The value can be anything you think to put in it.\r\n\r\n```js\r\n// include the mocha library (which was installed with npm)\r\nvar Mocha = require('mocha');\r\n\r\n// create an instance of the Mocha Test Runner \r\n// Use an options object \r\nvar mocha = new Mocha({\r\n    // the key is ui and the value is 'bdd'\r\n    ui: 'bdd',\r\n    // the key is reporter and the value is 'list'\r\n    reporter: 'list'\r\n});\r\n```\r\nAKA\r\n```js\r\n// include the mocha library (which was installed with npm)\r\nvar Mocha = require('mocha');\r\n\r\n// define the mocha options POJO\r\nvar mochaOptions = {\r\n  ui: 'bdd',\r\n  reporter: 'list'\r\n};\r\n\r\n// create an instance of the Mocha Test Runner \r\n// Use an options object \r\nvar mocha = new Mocha(mochaOptions);\r\n```\r\n\r\nTons of libraries use this pattern including\r\n\r\n**jQuery**\r\n\r\n```js\r\n$.ajax({\r\n  url: 'http://example.com',\r\n  type: 'GET',\r\n  async: true\r\n});\r\n```\r\n\r\n**Request**\r\n\r\n```js\r\nvar request = require('request');\r\n\r\nrequest({\r\n  method: 'GET',\r\n  url: 'http://example.com'\r\n});\r\n```\r\n\r\n**Twilio**\r\n\r\n```js\r\nvar Twilio = require('twilio');\r\nvar client = new Twilio(auth, creds);\r\n\r\nclient.sendMessage({\r\n    to: '+16515556677',\r\n    from: '+14506667788',\r\n    body: 'word to your mother.'\r\n});\r\n```\r\n\r\nBy using an object to pass named arguments into a function, an arbitrary number of required and optional fields can be added without changing the signature of the function which reduces the chances that code relying on the modified function will break.\r\n\r\nTake for example the process of searching for a red car with four wheels using some code your coworker wrote:\r\n\r\n```js\r\nvar cars = findCars(4, \"red\");\r\n```\r\n\r\nthis works for a while but things get harder when you want to want to find a compact sedan made by one of the brands you like\r\n\r\n```js\r\nvar cars = findCars(4, 'red', 'sedan', 'compact', 'tesla');\r\n```\r\n\r\nand things get down right impossible to read when we want to leave out search options and just find cars by tesla.\r\n\r\n```js\r\nvar cars = findCars(null, null, null, null, 'tesla');\r\n```\r\n\r\nThat code i a mess to maintain, and it gets worse when your coworker wants to make it possible to search for just those cars that have rear wheel drive.\r\n\r\n```js\r\nvar cars = findCars(4, 'red', 'sedan', 'compact', true, 'tesla');\r\n```\r\n\r\nNotice that by adding this feature to the findCars function, your coworker has broken your old code! \r\n\r\nFuture you will also be wondering what that `true` means when you come back to it in a couple of months.\r\n\r\n`findCars` could instead be written to take it's arguments using the options object and the rear wheel drive search features wouldn't have introduced a bug and future you will know what everything means.\r\n\r\n```js\r\nvar cars = findCars({\r\n  doors: 4,\r\n  color: 'red',\r\n  bodyStyle: 'sedan',\r\n  bodySize: 'compact',\r\n  manufacturer: 'tesla',\r\n  rearDriveOnly: true\r\n});\r\n```\r\n\r\n```js\r\nvar cars = findCars({\r\n  color: 'red',\r\n  bodyStyle: 'sedan',\r\n  manufacturer: 'tesla'\r\n});\r\n```\r\n\r\nYou'll notice that the options object allows you to call the function many different ways. It's a way in javascript to provide multiple signatures for a function by expecting different options depending on which action should happen. Other languages allow overloading the function signature for directly.\r\n\r\n**Note:** You might have noticed that a POJO looks similar to JSON formatted text. [[elaborate]]\r\n\r\n## First Class Functions\r\n\r\nIn Javascript, functions are \"First Class Citizens\". Anything that can be done with any other variable in Javascript can be done with functions. In fact, functions are just callable objects. ((Aside: Everything in Javascript decends from a common ancestor [[prove it!]]))\r\n\r\nTwo properties of functions in particular should be pointed out. They are important because each enables a common pattern in Javascript.\r\n\r\n* A function can be passed into another function as a parameter\r\n* A function can be returned from another function\r\n\r\n\r\n**Callbacks**\r\n\r\nThe first allows for \"callbacks\", which is a way to allow other code to execute and call the \"callback\" function when it is done.\r\n\r\n```js\r\nvar fs = require('fs');\r\nfs.readFile('sample.txt', function (err, data) {\r\n  console.log(\"I'm done reading the file so I'm running your callback\", err, data);\r\n});\r\n```\r\n\r\nIn `Node.js`, callbacks are traditionally called with a first parameter of `err`. This value will be `null` if there is not an error and checking for an error is a common first step when writing a `node.js` style callback. Let's dress up that first example a bit.\r\n\r\n```js\r\nvar fs = require('fs');\r\nfs.readFile('sample.txt', function (err, data) {\r\n  if (err) {\r\n    console.error(\"There was an error reading sample.txt\", err);\r\n    return;\r\n  }\r\n  console.log(\"The contents of sample.txt is: \", data);\r\n});\r\n```\r\n\r\n**Closures**\r\n\r\nThe second powers \"closures\". A closure is best explained first by example.\r\n\r\n```js\r\nfunction makeGreeter (greeting) {\r\n  return function greeter (name) {\r\n     console.log(greeting + \", \" + name);\r\n  }\r\n}\r\n\r\nvar greeter = makeGreeter(\"Hello\");\r\ngreeter(\"World\");\r\n// outputs:\r\n// Hello World\r\n```\r\n\r\nIn the example above, the value of `greeting` that was passed as an argument to `makeGreeter` is available to the greeter even though `greeting` seems locked into the scope of `makeGreeter`. [[Need more closure love]]\r\n\r\n\r\n## Chaining\r\n\r\nChaining is a mechanism by which a developer can call multiple methods, sequentially, on an object without much boiler plate.\r\n\r\nChaining works because each method on an object will return the object. Let's look at an example\r\n\r\n```js\r\nfunction makeApple() {\r\n    function setColor (color) {\r\n        apple.color = color;\r\n        return apple;\r\n    }\r\n\r\n    function setSize (size) {\r\n        apple.size = size;\r\n        return apple;\r\n    }\r\n\r\n    function setWeight (weight) {\r\n        apple.weight = weight;\r\n        return apple;\r\n    }\r\n    // hoisting will ensure this is declared in time.\r\n    var apple = {\r\n        setColor: setColor,\r\n        setSize: setSize,\r\n        setWeight: setWeight\r\n    };\r\n    return apple;\r\n}\r\n\r\nvar apple = makeApple();\r\n// make a large red apple of weight 8 ounces\r\napple.setColor('red').setSize('large').setWeight('8 oz');\r\nconsole.log(apple);\r\n// {color: 'red', size: 'large', weight: '8 oz' ...}\r\n```\r\n\r\n[jQuery](http://jquery.com/) is notorious for chaining.\r\n\r\n```js\r\n// select an element with id=\"p1\"\r\n$(\"#p1\")\r\n  // set the element's color to red\r\n  .css(\"color\", \"red\")\r\n  // slide the element up over a 2 second duration\r\n  .slideUp(2000)\r\n  // slide the element down over a 2 second duration, but only after the slideUp is finished.\r\n  .slideDown(2000);\r\n```\r\n\r\n[SuperTest](https://github.com/visionmedia/supertest) also leverages chaining to make writing tests more pleasant.\r\n\r\n```js\r\nvar request = require('supertest')\r\n  , express = require('express');\r\n\r\nvar app = express();\r\n\r\napp.get('/user', function(req, res){\r\n  res.send(200, { name: 'tobi' });\r\n});\r\n\r\nrequest(app)\r\n  .get('/user')\r\n  .expect('Content-Type', /json/)\r\n  .expect('Content-Length', '20')\r\n  .expect(200)\r\n  .end(function(err, res){\r\n    if (err) {\r\n        throw err;\r\n    }\r\n  });\r\n```\r\n\r\nIn the example above, the request is instructed what url to call and with what http method, the `Content-Type` header's expected value is defined, the `Content-Length` header's expected value is defined, the expected [HTTP Status Code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) is declared and the request will bubble any errors it throws.\r\n\r\n# Go Do a Thing\r\n\r\nKnowing the common patterns that other developers use when writing their libraries should prepare you to consume them. There are also other concepts that build on these other common patterns that you're now better prepared to tackle. (Such as [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise))\r\n\r\nThe best way to solidify these concepts is through repetition. Grab a package from [NPM](https://npmjs.org) and hack on something for some practice.","google":"UA-63026446-2","note":"Don't delete this file! It's used internally to help with page regeneration."}